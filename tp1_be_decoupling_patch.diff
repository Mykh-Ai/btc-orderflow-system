diff --git a/executor.py b/executor.py
index 29873ba..264c65c 100644
--- a/executor.py
+++ b/executor.py
@@ -1028,381 +1028,405 @@ def manage_v15_position(symbol: str, st: Dict[str, Any]) -> None:
                 oid = int((pos.get("orders") or {}).get(key) or 0)
             except Exception:
                 oid = 0
             if oid:
                 attempted.append((key, oid))
 
         # No real action -> no throttle/state/log (prevents log spam).
         if not attempted:
             return
 
         # throttle (default 2s; reuse watchdog retry if present)
         try:
             retry_sec = float(ENV.get("CLOSE_CLEANUP_RETRY_SEC") or 0.0)
         except Exception:
             retry_sec = 0.0
         if retry_sec <= 0.0:
             try:
                 retry_sec = float(ENV.get("SL_WATCHDOG_RETRY_SEC") or 0.0)
             except Exception:
                 retry_sec = 0.0
         if retry_sec <= 0.0:
             retry_sec = float(throttle_sec)
 
         pos["close_cleanup_next_s"] = now_s + retry_sec
         st["position"] = pos
         _save_state_best_effort("close_cleanup_throttle_set")
 
         for key, oid in attempted:
             _cancel_ignore_unknown(oid)
 
         # Log only when we actually attempted cancels.
         log_event(
             "CLOSE_CLEANUP_BEST_EFFORT",
             mode="live",
             tag=tag,
             count=len(attempted),
             keys=[k for (k, _) in attempted],
         )
 
     def _finalize_close(reason: str, tag: str) -> None:
         """
         AK-47 contract:
         - best-effort cleanup is allowed here (throttled)
         - _close_slot() stays pure (state/report/margin-hook only)
         - close must never be blocked by cleanup failures
         """
         with suppress(Exception):
             _cancel_sibling_exits_best_effort(tag=tag)
         _close_slot(reason)
 
-    def _tp1_be_transition(exit_side: str, be_stop: float, rem_qty: float, source: str) -> bool:
-        """Cancel current SL first, then place BE SL (throttled). Returns True if BE placed."""
+    def _tp1_be_transition_tick() -> bool:
+        """Cancel current SL first, then place BE SL (throttled). Returns True if BE placed.
+        
+        Reads parameters from pos["tp1_be_*"] state-machine fields.
+        """
         def _is_insufficient_balance_error(e: Exception) -> bool:
             # Binance can return different shapes; keep heuristic minimal.
             msg = str(e or "").lower()
             if ("insufficient" in msg and "balance" in msg) or ("not enough" in msg) or ("insufficient margin" in msg):
                 return True
             with suppress(Exception):
                 c = getattr(e, "code", None)
                 if c is not None:
                     c = int(c)
                     # Common exchange error for insufficient balance is -2010, but keep broad.
                     if c in (-2010,):
                         return True
             return False
 
         # Hard cap to avoid infinite state-machine loops / log+API spam.
         try:
             max_attempts = int(ENV.get("TP1_BE_MAX_ATTEMPTS") or 5)
         except Exception:
             max_attempts = 5
         if max_attempts <= 0:
             max_attempts = 5
 
         retry_sec = float(ENV.get("SL_WATCHDOG_RETRY_SEC") or 2.0)
         if retry_sec <= 0.0:
             retry_sec = 2.0
         next_s = float(pos.get("tp1_be_next_s") or 0.0)
         if now_s < next_s:
             return False
 
+        if not pos.get("tp1_be_pending"):
+            return False
+
         if pos.get("tp1_be_disabled"):
             return False
 
         try:
             attempts = int(pos.get("tp1_be_attempts") or 0)
         except Exception:
             attempts = 0
         if attempts >= max_attempts:
+            source = str(pos.get("tp1_be_source") or "UNKNOWN")
             pos["tp1_be_disabled"] = True
             pos["tp1_be_next_s"] = now_s + 3600.0  # stop hammering for 1h
             st["position"] = pos
             _save_state_best_effort("tp1_be_max_attempts_reached")
             log_event("TP1_BE_MAX_ATTEMPTS_REACHED", mode="live", attempts=attempts, max_attempts=max_attempts, source=source)
             send_webhook({
                 "event": "TP1_BE_MAX_ATTEMPTS_REACHED",
                 "mode": "live",
                 "symbol": symbol,
                 "attempts": attempts,
                 "max_attempts": max_attempts,
                 "source": source,
             })
             return False
 
-        if not pos.get("tp1_be_pending"):
-            old_sl_id = int((pos.get("orders") or {}).get("sl") or 0)
-            pos["tp1_be_pending"] = True
-            pos["tp1_be_old_sl"] = old_sl_id
-            pos["tp1_be_source"] = source
-            pos["tp1_be_attempts"] = int(pos.get("tp1_be_attempts") or 0)
-            pos["tp1_be_next_s"] = now_s
-            st["position"] = pos
-            _save_state_best_effort("tp1_be_pending_set")
-
+        # Read parameters from state-machine
+        exit_side = str(pos.get("tp1_be_exit_side") or "")
+        be_stop = float(pos.get("tp1_be_stop") or 0.0)
+        rem_qty = float(pos.get("tp1_be_rem_qty") or 0.0)
+        source = str(pos.get("tp1_be_source") or "UNKNOWN")
         old_sl_id = int(pos.get("tp1_be_old_sl") or 0)
         if old_sl_id:
             # STRICT: do not place new BE SL until old SL is confirmed canceled/not-found,
             # otherwise Binance may reject due to locked funds/qty.
             _cancel_ignore_unknown(old_sl_id)
 
             od_c = None
             cancel_ok = False
             st_c = ""
             try:
                 od_c = binance_api.check_order_status(symbol, old_sl_id)
                 st_c = str((od_c or {}).get("status", "")).upper()
             except Exception as e:
                 # Treat Binance -2013 / Unknown order as "already gone" => cancel_ok.
                 msg = str(e or "")
                 msg_l = msg.lower()
                 err_code = None
                 with suppress(Exception):
                     if getattr(e, "code", None) is not None:
                         err_code = int(getattr(e, "code"))
                 if err_code is None:
                     if '"code":-2013' in msg or '"code": -2013' in msg:
                         err_code = -2013
                 if err_code == -2013 or ("unknown order" in msg_l) or ("order does not exist" in msg_l):
                     st_c = "NOT_FOUND"
                 else:
                     st_c = ""
 
             # If status endpoint fails or returns empty, stay conservative and retry.
             if st_c in ("CANCELED", "REJECTED", "EXPIRED", "NOT_FOUND"):
                 cancel_ok = True
             elif st_c == "FILLED":
                 # SL got filled while transitioning; let normal SL-filled path handle closure.
                 cancel_ok = False
             elif st_c:
                 cancel_ok = False
             else:
                 cancel_ok = False
 
             if not cancel_ok:
                 pos["tp1_be_last_status"] = st_c or "UNKNOWN"
                 pos["tp1_be_next_s"] = now_s + retry_sec
                 st["position"] = pos
                 _save_state_best_effort("tp1_be_wait_cancel")
                 log_event("TP1_BE_WAIT_CANCEL", mode="live", order_id_sl=old_sl_id, status=st_c or "UNKNOWN")
                 return False
 
         if be_stop <= 0.0 or rem_qty <= 0.0:
             pos["tp1_be_last_error"] = "invalid_be_inputs"
             pos["tp1_be_next_s"] = now_s + retry_sec
             st["position"] = pos
             _save_state_best_effort("tp1_be_invalid_inputs")
             log_event("TP1_BE_INVALID_INPUTS", mode="live", be_stop=be_stop, rem_qty=rem_qty)
             return False
 
         tick = float(ENV["TICK_SIZE"])
         gap_ticks = max(1, int(ENV.get("SL_LIMIT_GAP_TICKS") or 0))
         gap = tick * float(gap_ticks)
         be_limit = (be_stop - gap) if exit_side == "SELL" else (be_stop + gap)
         be_stop_s = fmt_price(be_stop)
         be_limit_s = fmt_price(be_limit)
         if be_limit_s == be_stop_s:
             be_limit_s = fmt_price((be_stop - tick) if exit_side == "SELL" else (be_stop + tick))
 
         pos["tp1_be_attempts"] = int(pos.get("tp1_be_attempts") or 0) + 1
         client_suffix = "TP1WD" if source == "TP1_WATCHDOG" else "TP1"
         try:
             sl_new = binance_api.place_order_raw({
                 "symbol": symbol,
                 "side": exit_side,
                 "type": "STOP_LOSS_LIMIT",
                 "quantity": fmt_qty(rem_qty),
                 "price": be_limit_s,
                 "stopPrice": be_stop_s,
                 "timeInForce": "GTC",
                 "newClientOrderId": f"EX_SL_BE_{client_suffix}_{int(time.time())}",
             })
         except Exception as e:
             # If exchange says "insufficient balance", most likely old SL is still locking qty.
             if _is_insufficient_balance_error(e) and old_sl_id:
                 pos["tp1_be_last_error"] = f"insufficient_balance_wait_cancel: {str(e)}"
                 pos["tp1_be_next_s"] = now_s + retry_sec
                 st["position"] = pos
                 _save_state_best_effort("tp1_be_insufficient_balance_wait_cancel")
                 log_event("TP1_BE_INSUFFICIENT_BALANCE_WAIT_CANCEL", error=str(e), mode="live", source=source, order_id_sl=old_sl_id)
                 return False
             pos["tp1_be_last_error"] = str(e)
             pos["tp1_be_next_s"] = now_s + retry_sec
             st["position"] = pos
             _save_state_best_effort("tp1_be_place_error")
             log_event("TP1_BE_PLACE_ERROR", error=str(e), mode="live", source=source)
             send_webhook({"event": "TP1_BE_PLACE_ERROR", "mode": "live", "symbol": symbol, "error": str(e), "source": source})
             return False
 
         pos["orders"]["sl"] = _oid_int(sl_new.get("orderId"))
-        pos["tp1_done"] = True
         # Keep price-level in sync with new BE SL
         with suppress(Exception):
             (pos.setdefault("prices", {}))["sl"] = float(be_stop)
         # Make sure SL status polling doesn't stay throttled on stale schedule
         pos["sl_status_next_s"] = now_s
         # If any previous SL state flags exist, clear them
         pos.pop("sl_done", None)
         # Record old SL for orphan cleanup (should already be canceled, but keep best-effort)
         if old_sl_id:
             with suppress(Exception):
                 pos["orders"]["sl_prev"] = int(old_sl_id)
             pos["sl_prev_next_cancel_s"] = _now_s()
         pos.pop("tp1_be_disabled", None)
         pos.pop("tp1_be_pending", None)
         pos.pop("tp1_be_old_sl", None)
+        pos.pop("tp1_be_exit_side", None)
+        pos.pop("tp1_be_stop", None)
+        pos.pop("tp1_be_rem_qty", None)
         pos.pop("tp1_be_last_status", None)
         pos.pop("tp1_be_last_error", None)
         pos.pop("tp1_be_source", None)
+        pos.pop("tp1_be_attempts", None)
         pos.pop("tp1_be_next_s", None)
         st["position"] = pos
         save_state(st)
         event_name = "TP1_WATCHDOG_SL_TO_BE" if source == "TP1_WATCHDOG" else "TP1_DONE_SL_TO_BE"
-        log_event(event_name, mode="live", order_id_tp1=tp1_id, new_sl_order_id=sl_new.get("orderId"))
+        log_event(event_name, mode="live", new_sl_order_id=sl_new.get("orderId"))
         send_webhook({"event": event_name, "mode": "live", "symbol": symbol, "new_sl_order_id": sl_new.get("orderId"), "entry": be_stop})
+        # Note: tp1_done is already set when TP1_FILLED detected, independent of BE success
         return True
 
     def _close_slot(reason: str) -> None:
         st["last_closed"] = {
             "ts": iso_utc(),
             "mode": "live",
             "reason": reason,
             "side": pos.get("side"),
             "entry": (pos.get("prices") or {}).get("entry"),
         }
         with suppress(Exception):
             reporting.report_trade_close(st, pos, reason)
         send_trade_closed(st, pos, reason, mode="live")
         st["position"] = None
         st["cooldown_until"] = _now_s() + float(ENV["COOLDOWN_SEC"])
         st["lock_until"] = 0.0
         save_state(st)
         with suppress(Exception):
             margin_guard.on_after_position_closed(st)
 
     tp1_id = int(pos["orders"].get("tp1") or 0)
     tp2_id = int(pos["orders"].get("tp2") or 0)
     sl_id = int(pos["orders"].get("sl") or 0)
     sl_prev = int(pos["orders"].get("sl_prev") or 0)
 
     if pos.get("exit_cleanup_pending"):
         next_cleanup = float(pos.get("exit_cleanup_next_s") or 0.0)
         if now_s < next_cleanup:
             return
         if now_s >= next_cleanup:
             retry_ids = pos.get("exit_cleanup_order_ids") or []
             failed_ids: List[int] = []
             for oid in retry_ids:
                 err = _cancel_ignore_unknown(oid)
                 if err is not None:
                     failed_ids.append(int(oid))
                     pos["exit_cleanup_last_error"] = str(err)
             if not failed_ids:
                 reason = str(pos.get("exit_cleanup_reason") or "EXIT_CLEANUP_DONE")
                 pos["exit_cleanup_pending"] = False
                 pos["exit_cleanup_order_ids"] = []
                 pos["exit_cleanup_next_s"] = 0.0
                 pos.pop("exit_cleanup_reason", None)
                 st["position"] = pos
                 _save_state_best_effort("exit_cleanup_done")
                 log_event("EXIT_CLEANUP_DONE", mode="live", reason=reason)
                 _finalize_close(reason, tag="EXIT_CLEANUP_DONE")
                 return
             pos["exit_cleanup_order_ids"] = failed_ids
             pos["exit_cleanup_next_s"] = now_s + float(ENV.get("SL_WATCHDOG_RETRY_SEC") or 0.0)
             st["position"] = pos
             _save_state_best_effort("exit_cleanup_retry_schedule")
             log_event(
                 "EXIT_CLEANUP_RETRY_FAILED",
                 mode="live",
                 reason=pos.get("exit_cleanup_reason"),
                 failed_ids=failed_ids,
                 error=pos.get("exit_cleanup_last_error"),
             )
             return
 
     # Якщо після TP1 ми замінили SL на BE, але старий SL не скасувався (або cancel впав),
     # то треба повторювати cancel best-effort раз на N секунд (без перевірки openOrders).
     if sl_prev and pos.get("tp1_done"):
         now_s = _now_s()
         next_s = float(pos.get("sl_prev_next_cancel_s") or 0.0)
         if now_s >= next_s:
             pos["sl_prev_next_cancel_s"] = now_s + float(ENV.get("ORPHAN_CANCEL_EVERY_SEC", 30))
             st["position"] = pos
             save_state(st)
             with suppress(Exception):
                 binance_api.cancel_order(symbol, sl_prev)
 
-    # TP1 filled -> move SL to BE (entry) for remaining qty2+qty3
+    # TP1 filled -> set tp1_done immediately, then initiate BE state-machine
     if tp1_id and not pos.get("tp1_done"):
         poll_due = now_s >= float(pos.get("tp1_status_next_s") or 0.0)
         # Do not gate FILLED detection on openOrders/open_ids; throttle via tp1_status_next_s
         if poll_due or (not orders):
             pos["tp1_status_next_s"] = now_s + float(ENV["LIVE_STATUS_POLL_EVERY"])
             tp1_status_payload = None
             with suppress(Exception):
                 tp1_status_payload = binance_api.check_order_status(symbol, tp1_id)
             if isinstance(tp1_status_payload, dict):
                 if _update_order_fill(pos, "tp1", tp1_status_payload):
                     st["position"] = pos
                     _save_state_best_effort("tp1_fill_update")
             tp1_filled = False
             if isinstance(tp1_status_payload, dict):
                 tp1_filled = str(tp1_status_payload.get("status", "")).upper() == "FILLED"
             if tp1_filled:
+                # TP1 FILLED is a fact - accept it immediately
+                pos["tp1_done"] = True
+                st["position"] = pos
+                _save_state_best_effort("tp1_done_set")
+                log_event("TP1_DONE", mode="live", order_id_tp1=tp1_id)
+                
+                # Now initiate BE state-machine (separate from tp1_done)
                 exit_side = "SELL" if pos["side"] == "LONG" else "BUY"
                 be_stop = float(pos.get("entry_actual") or (pos.get("prices") or {}).get("entry") or 0.0)
-
                 qty2 = float((pos.get("orders") or {}).get("qty2") or 0.0)
                 qty3 = float((pos.get("orders") or {}).get("qty3") or 0.0)
                 rem_qty = float(round_qty(qty2 + qty3))
-                _tp1_be_transition(exit_side, be_stop, rem_qty, source="TP1")
+                
+                # Initialize BE state-machine with parameters
+                old_sl_id = int((pos.get("orders") or {}).get("sl") or 0)
+                pos["tp1_be_pending"] = True
+                pos["tp1_be_old_sl"] = old_sl_id
+                pos["tp1_be_exit_side"] = exit_side
+                pos["tp1_be_stop"] = be_stop
+                pos["tp1_be_rem_qty"] = rem_qty
+                pos["tp1_be_source"] = "TP1"
+                pos["tp1_be_attempts"] = 0
+                pos["tp1_be_next_s"] = now_s
+                st["position"] = pos
+                save_state(st)
             else:
                 # Log once to avoid spam; can happen if order exists but is not filled yet.
                 miss = pos.setdefault("missing_not_filled", {})
                 key = f"tp1:{tp1_id}"
                 if poll_due and not miss.get(key):
                     miss[key] = iso_utc()
                     st["position"] = pos
                     save_state(st)
                     log_event("TP1_NOT_FILLED", mode="live", order_id_tp1=tp1_id)
 
     # TP2 filled -> activate trailing SL for remaining qty3 (if configured)
     if tp2_id and not pos.get("tp2_done"):    
         poll_due = now_s >= float(pos.get("tp2_status_next_s") or 0.0)
         if poll_due or (not orders):
             pos["tp2_status_next_s"] = now_s + float(ENV["LIVE_STATUS_POLL_EVERY"])
             st["position"] = pos
             _save_state_best_effort("tp2_status_next_s")
 
             tp2_status_payload = None
             with suppress(Exception):
                 tp2_status_payload = binance_api.check_order_status(symbol, tp2_id)
             if isinstance(tp2_status_payload, dict):
                 if _update_order_fill(pos, "tp2", tp2_status_payload):
                     st["position"] = pos
                     _save_state_best_effort("tp2_fill_update")
             tp2_filled = False
             if isinstance(tp2_status_payload, dict):
                 tp2_filled = str(tp2_status_payload.get("status", "")).upper() == "FILLED"
         else:
             tp2_filled = False
         if tp2_filled:
             pos["tp2_done"] = True
             st["position"] = pos
             save_state(st)
             log_event("TP2_DONE", mode="live", order_id_tp2=tp2_id)
             send_webhook({"event": "TP2_DONE", "mode": "live", "symbol": symbol})
 
             qty3 = float((pos.get("orders") or {}).get("qty3") or 0.0)
             qty1 = float((pos.get("orders") or {}).get("qty1") or 0.0)
             tp1_filled_now = bool(pos.get("tp1_done"))
             if (not tp1_filled_now) and tp1_id:
                 with suppress(Exception):
                     tp1_filled_now = _status_is_filled(tp1_id)
             open_qty = qty3 if tp1_filled_now else (qty1 + qty3)
             if ENV.get("TRAIL_ACTIVATE_AFTER_TP2", True) and open_qty > 0.0:
 
                 # cancel TP1 best-effort (should already be filled, but do not assume)
                 if tp1_id:
                     with suppress(Exception):
                         binance_api.cancel_order(symbol, tp1_id)
@@ -2098,185 +2122,206 @@ def manage_v15_position(symbol: str, st: Dict[str, Any]) -> None:
                         if pos_side not in ("LONG", "SHORT"):
                             pos_side = "SHORT" if close_side == "BUY" else "LONG"
                         binance_api.flatten_market(symbol, pos_side, plan_qty, client_id=f"EX_TP_WD_{int(time.time())}")
                         market_ok = True
                         st["position"] = pos
                         _save_state_best_effort("tp_watchdog_market_ok")
 
                         # Log post-market events
                         if post_market_events:
                             for event in post_market_events:
                                 payload = {k: v for k, v in event.items() if k != "name"}
                                 log_event(event.get("name"), mode="live", **payload)
                     except Exception as e:
                         pos["tp_watchdog_last_market_error"] = str(e)
                         st["position"] = pos
                         _save_state_best_effort("tp_watchdog_market_err")
                         log_event("TP_WATCHDOG_MARKET_ERROR", error=str(e), mode="live", qty=plan_qty)
                         return
 
                     if not market_ok:
                         return
                 else:
                     # Still in retry window
                     return
 
         # Handle dust cases (TP1_PARTIAL_DUST, TP1_MISSING_DUST)
         elif action in ("TP1_PARTIAL_DUST", "TP1_MISSING_DUST"):
             dust_payload = {
                 "qty_raw": tp_plan.get("dust_qty_raw"),
                 "qty_quantized": tp_plan.get("dust_qty_quantized"),
                 "notional_raw": tp_plan.get("dust_notional_raw"),
                 "min_notional": tp_plan.get("min_notional"),
                 "min_qty": tp_plan.get("min_qty"),
                 "price_now": tp_plan.get("price_now"),
             }
             log_event(action, mode="live", **{k: v for k, v in dust_payload.items() if v is not None})
 
         # Handle ACTIVATE_SYNTHETIC_TRAILING
         elif action == "ACTIVATE_SYNTHETIC_TRAILING":
             if tp_plan.get("set_tp2_synthetic"):
                 pos["tp2_synthetic"] = True
             if tp_plan.get("activate_trail"):
                 pos["trail_active"] = True
                 pos["trail_qty"] = float(tp_plan.get("trail_qty") or 0.0)
             st["position"] = pos
             _save_state_best_effort("tp2_synthetic_trailing")
             log_event("TP2_SYNTHETIC_TRAILING_ACTIVATED", mode="live", trail_qty=pos.get("trail_qty"))
 
         # Apply state transitions
         if tp_plan.get("set_tp1_done"):
-            # Move SL to BE for remaining qty2+qty3 (cancel-first, throttled).
-            if tp_plan.get("move_sl_to_be"):
+            # TP1 FILLED is a fact - accept it immediately (independent of BE transition)
+            if not pos.get("tp1_done"):
+                pos["tp1_done"] = True
+                st["position"] = pos
+                _save_state_best_effort("tp1_watchdog_done")
+                log_event("TP1_DONE", mode="live", source="TP1_WATCHDOG")
+            
+            # Initiate BE state-machine (separate from tp1_done)
+            # Support both old and new plan keys for backward compatibility
+            should_init_be = tp_plan.get("init_be_state_machine") or tp_plan.get("move_sl_to_be")
+            if should_init_be and not pos.get("tp1_be_pending"):
                 exit_side = "SELL" if pos["side"] == "LONG" else "BUY"
                 be_stop = float(pos.get("entry_actual") or (pos.get("prices") or {}).get("entry") or 0.0)
-
                 qty2 = float((pos.get("orders") or {}).get("qty2") or 0.0)
                 qty3 = float((pos.get("orders") or {}).get("qty3") or 0.0)
                 rem_qty = float(round_qty(qty2 + qty3))
-                _tp1_be_transition(exit_side, be_stop, rem_qty, source="TP1_WATCHDOG")
-            else:
-                pos["tp1_done"] = True
+                
+                # Initialize BE state-machine with parameters
+                old_sl_id = int((pos.get("orders") or {}).get("sl") or 0)
+                pos["tp1_be_pending"] = True
+                pos["tp1_be_old_sl"] = old_sl_id
+                pos["tp1_be_exit_side"] = exit_side
+                pos["tp1_be_stop"] = be_stop
+                pos["tp1_be_rem_qty"] = rem_qty
+                pos["tp1_be_source"] = "TP1_WATCHDOG"
+                pos["tp1_be_attempts"] = 0
+                pos["tp1_be_next_s"] = now_s
                 st["position"] = pos
-                _save_state_best_effort("tp1_watchdog_done")
+                save_state(st)
 
         # Cancel orders from plan
         cancel_ids = tp_plan.get("cancel_order_ids") or []
         failed_ids: List[int] = []
         for oid in cancel_ids:
             err = _cancel_ignore_unknown(oid)
             if err is not None:
                 failed_ids.append(int(oid))
                 log_event("TP_WATCHDOG_CANCEL_ERROR", error=str(err), mode="live", order_id=oid)
 
         if failed_ids:
             pos["exit_cleanup_pending"] = True
             pos["exit_cleanup_order_ids"] = failed_ids
             pos["exit_cleanup_next_s"] = now_s + float(ENV.get("SL_WATCHDOG_RETRY_SEC") or 0.0)
             pos["exit_cleanup_reason"] = reason or "TP_WATCHDOG"
             st["position"] = pos
             _save_state_best_effort("exit_cleanup_pending_schedule_tp")
             log_event("EXIT_CLEANUP_PENDING", mode="live", reason=pos["exit_cleanup_reason"], failed_ids=failed_ids)
 
         st["position"] = pos
         _save_state_best_effort("tp_watchdog_complete")
 
     # SL filled -> close slot
     sl_id2 = int((pos.get("orders") or {}).get("sl") or 0)
     if not sl_id2 and not pos.get("sl_done"):
         recon = pos.get("recon") if isinstance(pos.get("recon"), dict) else {}
         sl_recon_status = str(recon.get("sl_status") or "").upper()
         # Freshness gate: avoid stale recon closing the wrong slot
         fresh_sec = float(ENV.get("SL_RECON_FRESH_SEC") or 120.0)
         ts = str(recon.get("sl_status_ts") or "")
         is_fresh = False
         if not ts:
             # If ts is missing (common in tests / older states), treat as fresh enough.
             is_fresh = True
         else:
             with suppress(Exception):
                 t = datetime.fromisoformat(ts.replace("Z", "+00:00"))
                 is_fresh = (datetime.now(timezone.utc) - t).total_seconds() <= fresh_sec
 
         st_open = pos.get("status") in ("OPEN", "OPEN_FILLED")
         if sl_recon_status == "FILLED" and is_fresh and st_open:
             log_event("SL_FILLED_MISSING_ID_FALLBACK", mode="live", status=sl_recon_status)
             send_webhook({"event": "SL_FILLED_MISSING_ID_FALLBACK", "mode": "live", "symbol": symbol, "status": sl_recon_status})
             _finalize_close("SL", tag="SL_FILLED_MISSING_ID_FALLBACK")
             return
     if sl_id2 and not pos.get("sl_done"):
         poll_due = now_s >= float(pos.get("sl_status_next_s") or 0.0)
 
         # Do not gate FILLED detection on openOrders/open_ids; throttle via sl_status_next_s
         if poll_due or (not orders):
             pos["sl_status_next_s"] = now_s + float(ENV["LIVE_STATUS_POLL_EVERY"])
             sl_status = ""
             if isinstance(sl_status_payload, dict):
                 sl_status = str(sl_status_payload.get("status", "")).upper()
             sl_filled = sl_status == "FILLED" if sl_status else _status_is_filled(sl_id2)
 
             if sl_filled:
                 pos["sl_done"] = True
                 st["position"] = pos
                 save_state(st)
                 log_event("SL_DONE", mode="live", order_id_sl=sl_id2)
                 send_webhook({"event": "SL_DONE", "mode": "live", "symbol": symbol})
                 _finalize_close("SL", tag="SL_FILLED")
             else:
                 miss = pos.setdefault("missing_not_filled", {})
                 key = f"sl:{sl_id2}"
                 if not miss.get(key):
                     miss[key] = iso_utc()
                     st["position"] = pos
                     save_state(st)
                     log_event("SL_NOT_FILLED", mode="live", order_id_sl=sl_id2)
 
+    # BE state-machine: run independently after all watchdog operations
+    # This transitions SL to break-even after TP1 FILLED (retries if needed)
+    if pos.get("tp1_be_pending"):
+        _tp1_be_transition_tick()
+
 
 # ===================== State =====================
 
 def _trail_desired_stop_from_agg(pos: dict) -> Optional[float]:
     """
     Compute desired trailing stop based on last swing from aggregated.csv v2:
     LONG uses LowPrice swings; SHORT uses HiPrice swings.
     trail_wait_confirm uses ClosePrice (bar close) for confirmation only.
     LONG: stop = swing_low - buffer
     SHORT: stop = swing_high + buffer
     """
     return trail._trail_desired_stop_from_agg(pos)
 
 def get_usdt_usdc_k() -> float:
     """Get USDC/USDT conversion ratio.
 
     Note: Uses direct API calls (not PriceSnapshot) because we need two different
     symbols simultaneously and PriceSnapshot is a singleton holding one symbol.
     This is called only during signal processing, not in tight loops.
     """
     mid_usdt = binance_api.get_mid_price("BTCUSDT")
     mid_usdc = binance_api.get_mid_price("BTCUSDC")
     return mid_usdc / mid_usdt
 
 def sync_from_binance(st: Dict[str, Any], reason: str = "unknown") -> None:
     """Best-effort reconciliation of executor state with Binance.
 
     Why:
       - container/VPS restart with state mismatch
       - manual SL/TP placement/cancel in UI
       - key rotation / partial state reset
 
     Strategy (minimal, safe):
       - Look at *tagged* openOrders (clientOrderId starts with 'EX_')
       - If we see tagged orders and local state is empty -> create/attach a live position shell
       - If local state says OPEN/PENDING but Binance has no tagged orders -> clear slot (assume closed/canceled)
       
     GATED: Only run on BOOT/MANUAL/RECOVERY or at most once per SYNC_BINANCE_THROTTLE_SEC.
     Prefer using snapshot if fresh to avoid duplicate openOrders calls.
 
     This avoids accidental double-opening after restarts.
     """
     if str(ENV.get("TRADE_MODE", "spot")).strip().lower() != "margin":
         return
     
     # GATE: Throttle sync_from_binance unless reason is BOOT/MANUAL/RECOVERY
     pos = st.get("position") or {}
     now_s = time.time()
     
     if reason not in ("BOOT", "MANUAL", "RECOVERY"):
diff --git a/executor_mod/exit_safety.py b/executor_mod/exit_safety.py
index f8e92aa..f2c701e 100644
--- a/executor_mod/exit_safety.py
+++ b/executor_mod/exit_safety.py
@@ -357,174 +357,174 @@ def tp_watchdog_tick(
     if not _is_finite(price_now) or price_now <= 0.0:
         return None
 
     is_long = str(pos.get("side")).upper() == "LONG"
 
     # A) TP1 Partial Fill Detection
     if tp1_id and not tp1_done and isinstance(tp1_status_payload, dict):
         tp1_status = str(tp1_status_payload.get("status", "")).upper()
         tp1_executed = _as_float(tp1_status_payload.get("executedQty"), default=0.0)
         tp1_orig = _as_float(tp1_status_payload.get("origQty"), default=0.0)
 
         if tp1_executed > 0.0 and tp1_status != "FILLED":
             # Partial fill detected
             qty_remaining_raw = max(tp1_orig - tp1_executed, 0.0)
             qty_remaining = max(_quantize_qty_floor(qty_remaining_raw, env), 0.0)
             qty_quantized = qty_remaining
 
             min_qty_f = _min_qty(env)
             min_notional_f = _min_notional(env)
             qty_step = env.get("QTY_STEP")
             try:
                 qty_step_f = float(qty_step)
             except Exception:
                 qty_step_f = 0.0
 
             if qty_remaining <= max(min_qty_f, qty_step_f):
                 qty_remaining = 0.0
 
             remaining_notional_raw = _notional(qty_remaining_raw, price_now)
             remaining_notional_plan = _notional(qty_remaining, price_now)
 
             # Dust check
             if qty_remaining_raw > 0.0 and (
                 qty_quantized <= 0.0
                 or (qty_quantized > 0.0 and qty_quantized < min_qty_f)
                 or (min_notional_f > 0.0 and remaining_notional_raw > 0.0 and remaining_notional_raw < min_notional_f)
             ):
                 # Dust - can't market close, but still do TP1_DONE transition
                 return {
                     "action": "TP1_PARTIAL_DUST",
                     "reason": "TP1_PARTIAL_DUST",
                     "qty": 0.0,
                     "dust_qty_raw": qty_remaining_raw,
                     "dust_qty_quantized": qty_quantized,
                     "dust_notional_raw": remaining_notional_raw,
                     "min_notional": min_notional_f,
                     "min_qty": min_qty_f,
                     "price_now": price_now,
                     "cancel_order_ids": [int(tp1_id)],
                     "set_tp1_done": True,
-                    "move_sl_to_be": True,
-                    "events": [
-                        {"name": "TP1_PARTIAL_DETECTED", "executedQty": tp1_executed, "order_id": tp1_id},
-                        {"name": "TP1_PARTIAL_DUST", "qty_raw": qty_remaining_raw, "qty_quantized": qty_quantized},
-                    ],
-                }
+                "init_be_state_machine": True,
+                "events": [
+                    {"name": "TP1_PARTIAL_DETECTED", "executedQty": tp1_executed, "order_id": tp1_id},
+                    {"name": "TP1_PARTIAL_DUST", "qty_raw": qty_remaining_raw, "qty_quantized": qty_quantized},
+                ],
+            }
 
             return {
                 "action": "MARKET_FLATTEN",
                 "reason": "TP1_PARTIAL_FALLBACK",
                 "qty": qty_remaining,
                 "side": "SELL" if is_long else "BUY",
                 "cancel_order_ids": [int(tp1_id)],
                 "set_tp1_done": True,
-                "move_sl_to_be": True,
+                "init_be_state_machine": True,
                 "events": [
                     {"name": "TP1_PARTIAL_DETECTED", "executedQty": tp1_executed, "order_id": tp1_id},
                     {"name": "TP1_MARKET_FALLBACK_PARTIAL"},
                 ],
             }
 
     # B) TP1 Missing/Canceled/Expired + Price Crossed
     if tp1_id and not tp1_done:
         tp1_missing = False
         if isinstance(tp1_status_payload, dict):
             tp1_status = str(tp1_status_payload.get("status", "")).upper()
             # "MISSING" is a synthetic status injected by executor when order is not found on exchange.
             if tp1_status in ("CANCELED", "REJECTED", "EXPIRED", "MISSING"):
                 tp1_missing = True
 
         if tp1_missing:
             tp1_price = _tp_price(pos, "tp1")
             if tp1_price is not None:
                 # Check if price crossed TP1
                 price_crossed = (price_now > tp1_price) if is_long else (price_now < tp1_price)
 
                 if price_crossed:
                     # Market close TP1 portion (qty1)
                     qty_to_close_raw = qty1
                     qty_to_close = max(_quantize_qty_floor(qty_to_close_raw, env), 0.0)
                     qty_quantized = qty_to_close
 
                     min_qty_f = _min_qty(env)
                     min_notional_f = _min_notional(env)
                     qty_step = env.get("QTY_STEP")
                     try:
                         qty_step_f = float(qty_step)
                     except Exception:
                         qty_step_f = 0.0
 
                     if qty_to_close <= max(min_qty_f, qty_step_f):
                         qty_to_close = 0.0
 
                     close_notional_raw = _notional(qty_to_close_raw, price_now)
                     close_notional_plan = _notional(qty_to_close, price_now)
 
                     # Dust check
                     if qty_to_close_raw > 0.0 and (
                         qty_quantized <= 0.0
                         or (qty_quantized > 0.0 and qty_quantized < min_qty_f)
                         or (min_notional_f > 0.0 and close_notional_raw > 0.0 and close_notional_raw < min_notional_f)
                     ):
                         # Dust - can't market close, but still do TP1_DONE transition
                         return {
                             "action": "TP1_MISSING_DUST",
                             "reason": "TP1_MISSING_PRICE_CROSSED_DUST",
                             "qty": 0.0,
                             "dust_qty_raw": qty_to_close_raw,
                             "dust_qty_quantized": qty_quantized,
                             "dust_notional_raw": close_notional_raw,
                             "min_notional": min_notional_f,
                             "min_qty": min_qty_f,
                             "price_now": price_now,
                             "cancel_order_ids": [int(tp1_id)] if tp1_id else [],
                             "set_tp1_done": True,
-                            "move_sl_to_be": True,
+                            "init_be_state_machine": True,
                             "events": [
                                 {"name": "TP1_MISSING_PRICE_CROSSED", "order_id": tp1_id, "tp1_price": tp1_price, "price_now": price_now},
                                 {"name": "TP1_MISSING_DUST", "qty_raw": qty_to_close_raw, "qty_quantized": qty_quantized},
                             ],
                         }
 
                     return {
                         "action": "MARKET_FLATTEN",
                         "reason": "TP1_MISSING_PRICE_CROSSED",
                         "qty": qty_to_close,
                         "side": "SELL" if is_long else "BUY",
                         "cancel_order_ids": [int(tp1_id)] if tp1_id else [],
                         "set_tp1_done": True,
-                        "move_sl_to_be": True,
+                        "init_be_state_machine": True,
                         "events": [
                             {"name": "TP1_MISSING_PRICE_CROSSED", "order_id": tp1_id, "tp1_price": tp1_price, "price_now": price_now},
                             {"name": "TP1_MARKET_FALLBACK"},
                         ],
                     }
 
     # C) TP2 Missing/Canceled/Expired -> Synthetic Trailing
     if tp2_id and not tp2_done and not tp2_synthetic:
         tp2_missing = False
         if isinstance(tp2_status_payload, dict):
             tp2_status = str(tp2_status_payload.get("status", "")).upper()
             if tp2_status in ("CANCELED", "REJECTED", "EXPIRED", "MISSING"):
                 tp2_missing = True
 
         if tp2_missing:
             # Activate synthetic trailing ONLY on q2+q3 (per spec)
             trail_qty = (qty2 + qty3)
             if trail_qty <= 0.0:
                 return None
 
             return {
                 "action": "ACTIVATE_SYNTHETIC_TRAILING",
                 "reason": "TP2_MISSING",
                 "qty": 0.0,  # No immediate market action
                 "cancel_order_ids": [int(tp2_id)] if tp2_id else [],
                 "set_tp2_synthetic": True,
                 "activate_trail": True,
                 "trail_qty": trail_qty,
                 "events": [
                     {"name": "TP2_MISSING_SYNTHETIC_TRAILING", "order_id": tp2_id, "trail_qty": trail_qty},
                 ],
             }
 
     return None

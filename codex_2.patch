
diff --git a/executor_mod/margin_guard.py b/executor_mod/margin_guard.py
index f68fb216693371af568e650139b6d118218bd735..c6bf7dd6137ad5485beb592ed5b4de748204281a 100644
--- a/executor_mod/margin_guard.py
+++ b/executor_mod/margin_guard.py
@@ -1,40 +1,93 @@
 # executor_mod/margin_guard.py
 from __future__ import annotations
+import time
 from typing import Any, Dict, Optional, Callable
 
+from executor_mod import margin_policy
+
 ENV: Dict[str, Any] = {}
 log_event: Optional[Callable[..., None]] = None
+api_client: Optional[Any] = None
 
-def configure(env: Dict[str, Any], log_event_fn: Callable[..., None]) -> None:
-    global ENV, log_event
+def configure(env: Dict[str, Any], log_event_fn: Callable[..., None], api: Optional[Any] = None) -> None:
+    global ENV, log_event, api_client
     ENV = env
     log_event = log_event_fn
+    api_client = api
 
 def is_margin_mode() -> bool:
     return (ENV.get("TRADE_MODE") or "").lower() == "margin"
 
 def on_startup(state: Dict[str, Any]) -> None:
     # Spot: no-op
     if not is_margin_mode():
         return
-    # Margin: placeholder for future checks
+    if not api_client:
+        return
+
+    margin = state.setdefault("margin", {})
+    ttl_s = float(ENV.get("MARGIN_DEBT_CHECK_TTL_SEC") or 3600.0)
+    now_s = time.time()
+    last_check = float(margin.get("debt_checked_at") or 0.0)
+    if last_check and (now_s - last_check) < ttl_s:
+        return
+
+    is_isolated = str(ENV.get("MARGIN_ISOLATED", "")).upper() == "TRUE"
+    margin["is_isolated"] = is_isolated
+    account = api_client.margin_account(is_isolated=is_isolated, symbol=ENV.get("SYMBOL"))
+    margin["borrowed_assets"] = margin_policy._borrowed_assets(account)
+    margin["debt_checked_at"] = now_s
     if log_event:
-        log_event("MARGIN_HOOK_STARTUP", note="stub")
+        log_event("MARGIN_HOOK_STARTUP", borrowed_assets=margin.get("borrowed_assets"))
 
-def on_before_entry(symbol: str, side: str, qty: float, plan: Dict[str, Any]) -> None:
+def on_before_entry(state: Dict[str, Any], symbol: str, side: str, qty: float, plan: Dict[str, Any]) -> None:
     if not is_margin_mode():
         return
+    if not api_client:
+        return
+
+    margin = state.setdefault("margin", {})
+    trade_key = plan.get("trade_key") or plan.get("trade_id") or plan.get("key")
+    if not trade_key:
+        trade_key = margin.get("active_trade_key")
+    if not trade_key:
+        seq = int(margin.get("trade_seq") or 0) + 1
+        margin["trade_seq"] = seq
+        trade_key = f"trade-{seq}"
+
+    is_isolated = str(ENV.get("MARGIN_ISOLATED", "")).upper() == "TRUE"
+    margin["is_isolated"] = is_isolated
+    plan_use = dict(plan)
+    plan_use.setdefault("trade_key", trade_key)
+    plan_use.setdefault("is_isolated", is_isolated)
+
+    margin_policy.ensure_borrow_if_needed(state, api_client, symbol, side, qty, plan_use)
     if log_event:
-        log_event("MARGIN_HOOK_BEFORE_ENTRY", symbol=symbol, side=side, qty=qty)
+        log_event("MARGIN_HOOK_BEFORE_ENTRY", symbol=symbol, side=side, qty=qty, trade_key=trade_key)
 
 def on_after_entry_opened(state: Dict[str, Any]) -> None:
     if not is_margin_mode():
         return
     if log_event:
         log_event("MARGIN_HOOK_AFTER_ENTRY", note="stub")
 
 def on_shutdown(state: Dict[str, Any]) -> None:
     if not is_margin_mode():
         return
-    if log_event:
-        log_event("MARGIN_HOOK_SHUTDOWN", note="stub")
+    if api_client:
+        with_log = log_event is not None
+        margin_policy.repay_if_any(state, api_client, ENV.get("SYMBOL", ""))
+        if with_log:
+            log_event("MARGIN_HOOK_SHUTDOWN", repaid=True)
+    elif log_event:
+        log_event("MARGIN_HOOK_SHUTDOWN", note="no_api")
+
+def on_after_position_closed(state: Dict[str, Any]) -> None:
+    if not is_margin_mode():
+        return
+    if api_client:
+        margin_policy.repay_if_any(state, api_client, ENV.get("SYMBOL", ""))
+        if log_event:
+            log_event("MARGIN_HOOK_AFTER_CLOSE", repaid=True)
+    elif log_event:
+        log_event("MARGIN_HOOK_AFTER_CLOSE", note="no_api")
 
